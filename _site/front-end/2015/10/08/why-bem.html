<!DOCTYPE HTML>
<!--[if IE 6]><html class="ie6 lte9 lte8 lte7 no-css3" lang="zh-cn"><![endif]-->
<!--[if IE 7]><html class="ie7 lte9 lte8 lte7 no-css3" lang="zh-cn"><![endif]-->
<!--[if IE 8]><html class="ie8 lte9 lte8 no-css3" lang="zh-cn"><![endif]-->
<!--[if IE 9]><html class="ie9 lte9 no-css3" lang="zh-cn"><![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8) | !(IE 9)  ]><!--><html lang="zh-cn" class='non-ie'><!--<![endif]-->
    <head>
        <meta charset="utf-8" />

        
            <meta name="description" content="2012年那会儿我接触到BEM，那时候资料不多，不说百度，就连谷歌上“能看的”文章也是几笔带过，最终还是要到官网上研究，打开审查元素工具，边看BEM官网页面元素的命名，边对照官网介绍的规范用法..." />
        

        <meta name="keywords" content="css,javascript,html5,前端,web,页面制作" />
        <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=0.5,maximum-scale=2,user-scalable=yes" /><!-- 响应式网页设计：initial-scale设定初始缩放比例 maximum-scale设定允许用户缩放到的最大比例 minimum-scale设定允许用户缩放到的最小比例 值范围从0.0到10.0 user-scalable设定是否允许用户进行手动缩放 值为yes或no -->
        <title>为什么我们需要BEM</title>

        <!-- page icon -->
        <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png" />

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" type="text/css" href="/css/syntax.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" type="text/css" href="/css/main.css" />

    </head>
    <body class="/front-end/2015/10/08/why-bem">
        <div class="header">
            <div class="wrap">
                <h1 class="logo">
                    <a href="/">lxjwlt's blog</a>
                </h1>
            </div>
        </div>

        <div class="directory" id="directory">
            <div class="directory__container" id="directory__container"></div>
            <ul class="directory__button-list">
                <li><a href="#" class="directory__button directory__button--expand" id='expand-button'>目录</a></li>
                <li><a href="#" class="directory__button directory__button--top" id='top-button'>top</a></li>
            </ul>
        </div>
        <div class='main wrap'>
        	<ul class="sidebar">
        		<li><a class='to-index-page' href="/">ALL</a></li>
        		
        			<li><a class='to-others-page' href="/others.html">OTHERS[4]</a></li>
        		
        			<li><a class='to-front-end-page' href="/front-end.html">FRONT-END[27]</a></li>
        		
        	</ul>
        	<div class="content post" id="post">
        		<h1 class='post-title'>为什么我们需要BEM</h1>
        		<p class='post-date'>2015-10-08</p>
        		<p><a href="https://www.zybuluo.com/lxjwlt/note/155372">&gt;&gt;更好的阅读体验</a></p>

<p>BEM是由Yandex公司推出的一套CSS命名规范，官方是这么描述它的：</p>

<blockquote>
<p>BEM是一种让你可以快速开发网站并对此进行多年维护的技术。</p>
</blockquote>

<p>一开始，Yandex公司推出的BEM，包括了规范以及其配套构建工具。如今提到的BEM主要是指其中的规范，在<a href="http://getbem.com/">BEM最新的推广页</a>中，对其的描述为：</p>

<blockquote>
<p>BEM是一种命名方法，能够帮助你在前端开发中实现可复用的组件和代码共享。</p>
</blockquote>

<p>2012年那会儿我接触到BEM，那时候资料不多，不说百度，就连谷歌上“能看的”文章也是几笔带过，最终还是要到官网上研究，打开审查元素工具，边看BEM官网页面元素的命名，边对照官网介绍的规范用法。</p>

<p>不过最近貌似BEM的文章多起来，提起其他CSS命名方法，如OOCSS，SMACSS，往往都会提及BEM，而且最近蛮多互联网公司喜欢介绍项目架构，不管ppt还是技术文章，其中也频频出现BEM的身影，甚至有推崇备至的。</p>

<p>BEM这套规范到如今已经有了多套改良版，但其中的思想是不变，在了解其思想的过程中，我们能了解到它到底为了解决什么问题，明白CSS难以维护到底是哪里出了问题，自然我们也就明白了以后编写CSS的时候要规避什么问题。所以不管遵循不遵循，BEM还是值得我们去了解一下的，</p>

<h2>BEM解决的问题</h2>

<p>css的样式应用是全局性的，没有作用域可言。考虑以下场景</p>

<p>场景一：开发一个弹窗组件，在现有页面中测试都没问题，一段时间后，新需求新页面，该页面一打开这个弹窗组件，页面中样式都变样了，一查问题，原来是弹窗组件和该页面的样式相互覆盖了，接下来就是修改覆盖样式的选择器...又一段时间，又开发新页面，每次为元素命名都心惊胆战，求神拜佛，没写一条样式，F5都按多几次，每个组件都测试一遍...</p>

<p>场景二：承接上文，由于页面和弹窗样式冲突了，所以把页面的冲突样式的选择器加上一些结构逻辑，比如子选择器、标签选择器，借此让选择器独一无二。一段时间后，新同事接手跟进需求，对样式进行修改，由于选择器是一连串的结构逻辑，看不过来，嫌麻烦，就干脆在样式文件最后用另一套选择器，加上了覆盖样式...接下来又有新的需求...最后的结果，一个元素对应多套样式，遍布整个样式文件...</p>

<p>以往开发组件，我们都用“重名概率小”或者干脆起个“当时认为是独一无二的名字”来保证样式不冲突，这是不可靠的。</p>

<p>理想的状态下，我们开发一套组件的过程中，我们应该可以随意的为其中元素进行命名，而不必担心它是否与组件以外的样式发生冲突。</p>

<p>BEM解决这一问题的思路在于，由于项目开发中，每个组件都是唯一无二的，其名字也是独一无二的，组件内部元素的名字都加上组件名，并用元素的名字作为选择器，自然组件内的样式就不会与组件外的样式冲突了。</p>

<p>这是通过组件名的唯一性来保证选择器的唯一性，从而保证样式不会污染到组件外。</p>

<p>这也可以看作是一种“硬性约束”，因为一般来说，我们的组件会放置在同一目录下，那么操作系统中，同一目录下文件名必须唯一，这一点也就确保了组件之间不会冲突。</p>

<p>BEM的命名规矩很容易记：block-name__element-name--modifier-name，也就是模块名 + 元素名 + 修饰器名。</p>

<p>一般来说，根据组件目录名来作为组件名字：</p>

<p>比如分页组件：</p>

<p>/app/components/page-btn/</p>

<p>那么该组件模块就名为<code>page-btn</code>，组件内部的元素命名都必须加上模块名，比如：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;page-btn&quot;</span><span class="nt">&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">&quot;button&quot;</span> <span class="na">class=</span><span class="s">&quot;page-btn__prev&quot;</span><span class="nt">&gt;</span>上一页<span class="nt">&lt;/button&gt;</span>
   <span class="c">&lt;!-- ... --&gt;</span>
   <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">&quot;button&quot;</span> <span class="na">class=</span><span class="s">&quot;page-btn__next&quot;</span><span class="nt">&gt;</span>下一页<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>上面我们用双下划线来明确区分模块名和元素名，当然也可以用单下划线，比如<code>page-btn_prev</code>和<code>page-btn_next</code>。我们只需保留BEM的思想，其命名规范可以任意变通。</p>

<p>一开始了解BEM的时候，可能会产生误解，出现以下不正确的命名方式：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;page-btn&quot;</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- ... --&gt;</span>
   <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;page-btn__list&quot;</span><span class="nt">&gt;</span>
       <span class="nt">&lt;li</span> <span class="na">class=</span><span class="s">&quot;page-btn__list__item&quot;</span><span class="nt">&gt;</span>
           <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;#&quot;</span> <span class="na">class=</span><span class="s">&quot;page-btn__list__item__link&quot;</span><span class="nt">&gt;</span>第一页<span class="nt">&lt;/a&gt;</span>
       <span class="nt">&lt;/li&gt;</span>
   <span class="nt">&lt;/ul&gt;</span>
   <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>分页组件有个ul列表名为：<code>page-btn__list</code>，列表里面存放每一页的按钮，名为：<code>page-btn__list__item__link</code>，这是不对的。</p>

<p>首先，有悖BEM命名规范，BEM的命名中只包含三个部分，元素名只占其中一部分，所以不能出现多个元素名的情况，所以上述每一页的按钮名可以改成：<code>page-btn__btn</code>。</p>

<p>其次，有悖BEM思想，BEM是不考虑结构的，比如上面的分页按钮，即使它是在ul列表里面，它的命名也不应该考虑其父级元素。当我们遵循了这个规定，无论父元素名发生改变，或是模块构造发生的改变，还是元素之间层级关系互相变动，这些都不会影响元素的名字。</p>

<p>所以即使需求变动了，分页组件该有按钮还是要有按钮的，DOM构造发生变动，至多也就不同元素的增删减，模块内名称也随之增删减，而不会出现修改名字的情况，也就不会因为名字变动，牵涉到JS文件的修改，或样式文件的修改。</p>

<h2>BEM命名好长</h2>

<p>BEM的命名中包含了模块名，长长的命名会让HTML标签会显得臃肿。</p>

<p>其实每个使用BEM的开发团队多多少少会改变其命名规范，比如Instagram团队使用的驼峰式:</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.blockName-elementName--modifierName</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
</code></pre></div>
<p>还有单下划线：</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.block-name_element-name--modifierName</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
</code></pre></div>
<p>还有修饰器名用单横线连接：</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.blockName__elementName-modifierName</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
</code></pre></div>
<p>其实这些对缩短命名没有多大的帮助，但我们也无需担心文件体积的问题，由于服务端有gzip压缩，BEM命名相同的部分多，压缩下来的体积不会太大。另外现在都用IDE来编写代码了，有自动提示功能，也无须担心重复的输入过长的名字。</p>

<p>因为命名长，我们是不是可以用子代选择器来代替BEM命名？这样至少在HTML编写时，让HTML标签看起来美观一点。</p>

<p>下面说说子代选择器带来的问题。</p>

<h2>子选择器</h2>

<p>子代选择器的方式是，通过组件的根节点的名称来选取子代元素。按照这个思路，分页按钮样式可以这么写：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;page-btn&quot;</span><span class="nt">&gt;</span>
   <span class="c">&lt;!-- ... --&gt;</span>
   <span class="nt">&lt;ul</span> <span class="na">class=</span><span class="s">&quot;list&quot;</span><span class="nt">&gt;&lt;/ul&gt;</span>
   <span class="c">&lt;!-- ... --&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div><div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.page-btn</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>

<span class="nc">.page-btn</span> <span class="nc">.list</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
</code></pre></div>
<p>HTML看起来美观多了，但这解决了样式冲突问题么？试想下，如果让你来接手这个项目，要增加一个需求，新增一个组件，你命名放心么？</p>

<p>你面临的问题是：你打开组件目录，里面有个分页组件，叫做<code>page-btn</code>，可是你完全不知道要怎么给新组件命名，因为即使新组件模块名与<code>page-btn</code>不一样，也不能保证新组件与分页组件不冲突。</p>

<p>比如新的需求是“新增一个列表组件”，如果该组件的名字叫做list，其根节点的名字叫<code>list</code>，那么这个组件下面写的样式，就很可能和<code>.page-btn .list</code>的样式冲突:</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.list</span> <span class="p">{</span> <span class="c">/* ... */</span> <span class="p">}</span>
</code></pre></div>
<p>这还仅仅只有两个组件而已，实际项目中，十几个或几十个组件，难道我们要每个组件都检查一下来“新组件名是否和以往组件的子元素命名冲突了”么？这不现实。</p>

<p>BEM禁止使用子代选择器，以上是原因之一。子代选择器不好的地方还在于，如果<strong>层次关系过长</strong>，逻辑不清晰，非常不利于维护。为了懒得命名或者追求所谓的“精简代码”，写出下面这种选择器：</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.page-btn</span> <span class="nt">button</span><span class="nd">:first-child</span> <span class="p">{}</span>

<span class="nc">.page-btn</span> <span class="nt">ul</span> <span class="nt">li</span> <span class="nt">a</span> <span class="p">{}</span>

<span class="c">/* ... */</span>

<span class="c">/* 维护代码，新增需求 */</span>
<span class="nc">.page-btn</span> <span class="nc">.prev</span> <span class="p">{}</span>
</code></pre></div>
<p>用层次关系结构关系来定位元素，可能会因为需求改变而大面积的重写样式文件。试想一下维护这类代码有多么痛苦，我们要一边检查该元素的上下文DOM结构，一边对照着css文件，一一对比，找到该元素对应的样式，也就是说我为了改一个元素的代码，需要不断翻阅HTML文件和CSS文件，可维护性非常之差。更有甚者，来维护这块代码的同事，直接<strong>在样式文件最后</strong>添加覆盖样式，这会造成一个<strong>非常严重</strong>的问题了：同一个元素样式零散的分布在文件的不同地方，而且定位该元素的选择器也可能各不相同。</p>

<p>这样的样式文件只会越写越糟糕，可以说，当我们用子代选择器来定位元素时，这个样式文件就已经注定是要被翻来覆去的重构的了，甚至，每个来维护这个文件的人都会将其重构一遍。</p>

<p>子代选择器还会造成权重过大的问题，当我们要做响应式的时候，某个带样式的元素需要适配不同的屏幕，此时，我们还要<strong>不断的</strong>确认该元素之前的选择器写法！为了覆盖前面权重过大的样式，甚至通过添加<strong>额外的类名或标签名</strong>来增加权重。可想而知，此后这个样式文件的维护难度就像雪球一样，越滚越大。</p>

<p>如果我们用的是BEM，要覆盖样式很简单：找到要覆盖样式的元素，得知它的类名，在媒体查询中，用它的类名作为选择器，写下覆盖样式，样式就覆盖成功了，不需要担心前面样式的权重过大。</p>

<h2>BEM修饰器</h2>

<p>根据不同的场景，组件可能会表现出不同的样式。比如分页组件在pc端具有具体的页码以及上下页按钮，但在移动端，因空间有限，可能只保留上下页按钮。我们可以用修饰器来区分这两种情况。默认情况下，分页按钮的类名为<code>page-btn</code>，但在移动端，我们需要加多个类名<code>page-btn--min</code></p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="c">/* 缩小版分页组件中，具体页码按钮隐去 */</span>
<span class="nc">.page-btn--min</span> <span class="nc">.page-btn__btn</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.page-btn--min</span> <span class="nc">.page-btn__prev</span> <span class="p">{</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">50%</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.page-btn--min</span> <span class="nc">.page-btn__prev</span> <span class="p">{</span>
    <span class="k">width</span><span class="o">:</span> <span class="m">50%</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>上面这种情况用了子代选择器，BEM是不允许这么写的，BEM中修饰器的样式不依赖于任何结构关系，也就是说，元素的状态改变只会影响自身，不对其他元素进行影响，但实际上，这很难做到的。以上的写法不会造成样式冲突的，而且权重的影响也不大。</p>

<p>BEM修饰器代表着元素的状态，但有时候元素的状态需要js来控制，此时遵循规范没有任何好处，比如激活状态，BEM推荐的写法是：</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.block__element</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.block__element--active</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">block</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>当用js为该元素添加状态时，我们需要知道该元素的名字<code>block__element</code>，这样我们才能推导出它的激活状态为<code>block__element--active</code>，这是不合理的，因为很多时候我们无法得知元素的名称，所以这时候，我们应该统一js控制状态的类名格式，比如<code>is-active</code>、<code>js-active</code>等等，这些类名只用作<strong>标识</strong>，不予许有默认的公共样式：</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="nc">.block__element</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">none</span><span class="p">;</span>
<span class="p">}</span>

<span class="nc">.block__element.is-active</span> <span class="p">{</span>
    <span class="k">display</span><span class="o">:</span> <span class="k">block</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2>原子类和BEM</h2>

<p>BEM可以不需要用到原子类，但是如果已经引入了类似Bootstrap的框架，也没必要强制避免使用原子类，比如“pull-right”、&quot;ellipsis&quot;、“clearfix”等等类，这些类非常实用，和BEM是可以互补的。</p>

<p>在组件开发中其实不推荐使用原子类，因为这会降低组件的可复用性。可复用性的最理想状态就是组件不仅仅在不同的页面中表现一致，在跨项目的情况下，也能够运行良好。如果组件的样式因为依赖于某<strong>几个</strong>原子类就要依赖整个Bootstrap库，那么组件d 迁移负担就重很多了。</p>

<p>原子类更适合应用在实际页面中，这是因为页面<strong>变动大而且不可复用</strong>，假设在header中，我们用到了两个组件logo和user-panel（用户操作面板），两个组件分别置于header的左侧和右侧，我们可以这么写：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;header clearfix&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;logo pull-left&quot;</span><span class="nt">&gt;</span><span class="c">&lt;!-- ... --&gt;</span><span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;user-panel pull-left&quot;</span><span class="nt">&gt;</span><span class="c">&lt;!-- ... --&gt;</span><span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>header可以封装成一个模块，但它复用程度不高，不能算是组件，所以即使使用原子类也没有关系。在项目中，使用原子类之前应该考虑一下，这个场景是否<strong>变动大而且不可复用</strong>，如果是的话，我们可以放心的使用原子类。</p>

<p>组件应该是“自洽的”，其本身就应该构成了一个“生态圈”，也就是说，他几乎不需要外部供给，自给自足就能够运转下去。</p>

<h2>实际页面中也应该使用BEM</h2>

<p>在实际页面中也需要用到BEM命名方法，不然乱起的一个名字很可能就和某一组件冲突了，导致样式相互覆盖。</p>

<p>假如我们有联系页面，路径是/pages/contact/。那么该页面的模块名可以是page-contact，其名下元素均以<code>page-contact__element-name</code>命名。</p>

<p>一般来说，实际页面中只是对组件进行调用，对组件的位置进行调整，但不会对组件内部细节进行修改。但实际情况下，同一个组件在不同页面不同模样的情况也是有的，所以会出现在实际页面中对组件样式进行微调的代码：</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="c">/* 联系页面对分页按钮进行微调 */</span>
<span class="nc">.page-contact</span> <span class="nc">.page-btn</span> <span class="p">{}</span>
</code></pre></div>
<p>但更推荐的做法是给分页组件添加一个修饰器，将上面的样式放到修饰器名下，再根据实际情况运用到页面中。</p>

<h2>webpack css-loader 解决之道</h2>

<p>BEM主要被诟病的一点在于其命名过长，结合Angular这种带有标签指令的框架时，整个HTML看起来会更混乱：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="c">&lt;!-- 发帖页面 --&gt;</span>
<span class="nt">&lt;span</span> <span class="na">ng-repeat=</span><span class="s">&quot;post in postData track by post.id&quot;</span> <span class="na">ng-if=</span><span class="s">&quot;$index === 0&quot;</span> <span class="na">class=</span><span class="s">&quot;page-post__post-item&quot;</span> <span class="na">ng-class=</span><span class="s">&quot;{&#39;page-post__post-item--even&#39;: $even}&quot;</span> <span class="na">popover-content=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>

<span class="nt">&lt;/span&gt;</span>
</code></pre></div>
<p>当然，我们可以通过换行来缓解这个问题:</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="c">&lt;!-- 发帖页面 --&gt;</span>
<span class="nt">&lt;span</span> <span class="na">ng-repeat=</span><span class="s">&quot;post in postData track by post.id&quot;</span> 
      <span class="na">ng-if=</span><span class="s">&quot;$index === 0&quot;</span> 
      <span class="na">class=</span><span class="s">&quot;page-post__post-item&quot;</span> 
      <span class="na">ng-class=</span><span class="s">&quot;{&#39;page-post__post-item--even&#39;: $even}&quot;</span> 
      <span class="na">popover-content=</span><span class="s">&quot;&quot;</span><span class="nt">&gt;</span>


<span class="nt">&lt;/span&gt;</span>
</code></pre></div>
<p>但其实说穿了，BEM保证样式不冲突的核心就是：在元素名中加入唯一的标识。这个标识在BEM中对应的是模块名，也可能是一个独一无二的乱序字符串。</p>

<p>为模块中每个元素名加入标识，这可是重复的工作啊，重复的工作就应该交给机器去做。</p>

<p><a href="https://webpack.github.io/">webpack</a>加载器css-loader，可在js中读取css样式，自2015年4月份起，该插件加入了placeholder功能，使得该插件可以解决CSS作用域的问题，原理也就是给元素的名称加入唯一的标识。</p>
<div class="highlight"><pre><code class="language-css" data-lang="css"><span class="c">/* 分页组件 */</span>
<span class="nd">:local</span><span class="o">(</span><span class="nc">.prev</span><span class="o">)</span> <span class="p">{}</span>
</code></pre></div>
<p>css-loader加载器自定义的语法：<code>:local(.identifier){}</code>向外暴露出选择器<code>.prev</code>。在JS代码中，我们可以拿到这个选择器：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">styles</span> <span class="nx">from</span> <span class="s1">&#39;./page-btn.css&#39;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">$prevBtn</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;button class=&quot;&#39;</span> <span class="o">+</span> <span class="nx">styles</span><span class="p">.</span><span class="nx">prev</span> <span class="o">+</span> <span class="s1">&#39;&quot;&gt;上一页&lt;/button&gt;&#39;</span><span class="p">);</span>

<span class="c1">// ...</span>
</code></pre></div>
<p><code>styles.prev</code>返回的是一串独一无二且随机的字符串，该字符串对应着样式文件中的选择器。这名字有悖语义化，但css-loader支持配置字符串的生成格式，有兴趣的童鞋可以看看这篇文章：<a href="https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284">The End of Global CSS</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.w3ctech.com/topic/1479">CSS Modules Welcome to the Future</a></li>
<li><a href="http://csswizardry.com/2015/08/bemit-taking-the-bem-naming-convention-a-step-further/">BEMIT: Taking the BEM Naming Convention a Step Further</a></li>
<li><a href="https://en.bem.info/method/naming-convention/">BEM naming convention</a></li>
<li><a href="https://css-tricks.com/bem-101/">BEM 101</a></li>
</ul>

        		<!-- Duoshuo Comment BEGIN -->
        		<div class="ds-thread"></div>
        		<script type="text/javascript">
        			var duoshuoQuery = {short_name:"lxjwlt"};
        			(function() {
        				var ds = document.createElement('script');
        				ds.type = 'text/javascript';ds.async = true;
        				ds.src = 'http://static.duoshuo.com/embed.js';
        				ds.charset = 'UTF-8';
        				(document.getElementsByTagName('head')[0]
        				|| document.getElementsByTagName('body')[0]).appendChild(ds);
        			})();
        		</script>
        		<!-- Duoshuo Comment END -->
        	</div>
        </div>

        <script src="/scripts/sea.js"></script>
        <script>
            seajs.use('post');
        </script>
    </body>
</html>
