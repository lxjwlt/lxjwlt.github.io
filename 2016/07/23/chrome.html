<!DOCTYPE HTML>
<!--[if IE 6]><html class="ie6 lte9 lte8 lte7 no-css3" lang="zh-cn"><![endif]-->
<!--[if IE 7]><html class="ie7 lte9 lte8 lte7 no-css3" lang="zh-cn"><![endif]-->
<!--[if IE 8]><html class="ie8 lte9 lte8 no-css3" lang="zh-cn"><![endif]-->
<!--[if IE 9]><html class="ie9 lte9 no-css3" lang="zh-cn"><![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8) | !(IE 9)  ]><!--><html lang="zh-cn" class='non-ie'><!--<![endif]-->
    <head>
        <meta charset="utf-8" />

        
            <meta name="description" content="<p>如今Chrome浏览器无疑是最受前端青睐的工具，原因除了界面简洁、大量的应用插件，良好的代码规范支持、强大的V8解释器之外，还因为Chrome开发者工具提供了大量的便捷功能，方便我们前端调试代码，我们在日常开发中是越来越离不开Chrome，是否熟练掌握Chrome调试技巧恐怕也会成为考量前端技术水平的标杆。</p>
" />
        

        <meta name="keywords" content="css,javascript,html5,前端,web,页面制作" />
        <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=0.5,maximum-scale=2,user-scalable=yes" /><!-- 响应式网页设计：initial-scale设定初始缩放比例 maximum-scale设定允许用户缩放到的最大比例 minimum-scale设定允许用户缩放到的最小比例 值范围从0.0到10.0 user-scalable设定是否允许用户进行手动缩放 值为yes或no -->
        <title>Chrome 实用调试技巧</title>

        <!-- page icon -->
        <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png" />

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" type="text/css" href="/css/syntax.css" />

        <!-- Custom CSS -->
        <link rel="stylesheet" type="text/css" href="/css/main.css" />

    </head>
    <body class="/2016/07/23/chrome">
        <div class="header">
            <div class="wrap">
                <h1 class="logo">
                    <a href="/">lxjwlt's blog</a>
                </h1>
            </div>
        </div>

        <div class="directory" id="directory">
            <div class="directory__container" id="directory__container"></div>
            <ul class="directory__button-list">
                <li><a href="#" class="directory__button directory__button--expand" id='expand-button'>目录</a></li>
                <li><a href="#" class="directory__button directory__button--top" id='top-button'>top</a></li>
            </ul>
        </div>
        <div class='main wrap'>
        	<ul class="sidebar">
        		<li><a class='to-index-page' href="/">ALL</a></li>
        		
        			<li><a class='to-others-page' href="/others.html">OTHERS[4]</a></li>
        		
        			<li><a class='to-front-end-page' href="/front-end.html">FRONT-END[28]</a></li>
        		
        	</ul>
        	<div class="content post" id="post">
        		<h1 class='post-title'>Chrome 实用调试技巧</h1>
        		<p class='post-date'>2016-07-23</p>
        		<p>如今Chrome浏览器无疑是最受前端青睐的工具，原因除了界面简洁、大量的应用插件，良好的代码规范支持、强大的V8解释器之外，还因为Chrome开发者工具提供了大量的便捷功能，方便我们前端调试代码，我们在日常开发中是越来越离不开Chrome，是否熟练掌握Chrome调试技巧恐怕也会成为考量前端技术水平的标杆。</p>

<p>介绍Chrome调试技巧的文章很多，本文结合我自己的开发经验，希望从实际运用的角度为大家<strong>再一次</strong>谈一谈这些功能，也希望对大家都有所帮助和启发。</p>

<p><a href="https://www.zybuluo.com/lxjwlt/note/434612">更好的阅读体验&gt;&gt;</a></p>

<h2>常用快捷键</h2>

<p><strong>ctrl+p</strong> 项目中定位文件，以下查找<a href="http://cn.vuejs.org/">VueJS</a>库文件：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/shotcut-1.gif" alt=""></p>

<p><strong>ctrl+shif+o</strong> 文件中定位成员函数，以下定位到VueJS的nextTick接口：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/shotcut-2.gif" alt=""></p>

<h2>Snippets 随时编写代码</h2>

<p>Chrome在souces页面提供snippets一栏，这里我们可以随时编写JS代码，运行结果会打印到控制台。代码是全局保存的，我们在任何页面，包括新建标签页，都可以查看或运行这些代码。</p>

<p>我们不再需要为了运行一小段JS代码而新建一个HTML页面。snippets的方便之处在于，你只需要打开chrome就可以编写一份任意页面都可以运行的JS代码，而且用过snippets都知道，snippets编辑器是可以和sublime text相媲美的。</p>

<p>某次项目中，我需要将100多页的word文档导入到页面中。考虑后续样式编写，页面的HTML结构如下：</p>
<div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;help-page_row&quot;</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h3</span> <span class="na">class=</span><span class="s">&quot;help-page_title&quot;</span><span class="nt">&gt;</span>title<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;help-page_desc&quot;</span><span class="nt">&gt;</span>paragraph<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;help-page_desc&quot;</span><span class="nt">&gt;</span>paragraph<span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>
<p>手工将100多页的内容组合成上面的HTML结构太过耗费时间，不太现实，所以我决定使用JS来将文档内容的标题和段落解析出来，并进行HTML包装。</p>

<p>由于不需要视图的支持，在snippets编写这段代码是最好的选择，经过几次调试修改，最终成果如下：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/snippet-0.png" alt=""></p>

<p>最后，将Word文档内容复制到snippets中，执行解析函数，最终的解析出来的HTML结果打印到控制台：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/snippet-2.png" alt=""></p>

<blockquote>
<p>snippets中可以使用控制台的copy接口，解析结果直接拷贝到剪切板会更方便</p>
</blockquote>

<p>使用snippets来完成这类轻量级工作时，不需要追求代码的可读性、可维护性，我们的代码只需要在大部分场景下能够正常运行就足够了。</p>

<p>但为了满足大部分场景，代码也是需要反复调试修改。snippets最实用之处恰恰在于，<strong>随时编写，随时调试，随时修改！</strong></p>

<h2>copy 格式化拷贝</h2>

<p>在项目开发中，我们可能需要将后台数据拷贝到本地，作为本地数据进行调试。</p>

<p>如果后台返回没有格式化的JSON数据，在本地调试中我们难免会遇到手动修改数据的情况，格式不美观的JSON数据修改起来会异常困难。</p>

<p>说到JSON的格式化，我们首先想到的是<a href="http://devdocs.io/javascript/global_objects/json/stringify">JSON.stringify</a>的格式化功能，例如四个空格的缩进：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;lxjwlt&#39;</span><span class="p">},</span> <span class="kc">null</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div>
<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/copy-2.png" alt=""></p>

<p>每次格式化JSON数据都要编写这段代码实在太麻烦，我们可以使用chrome控制台的copy接口解决这一问题：</p>

<ol>
<li>请求项的右键菜单中选择<strong>Copy Response</strong>拷贝响应内容</li>
<li>命令行中使用<strong>copy</strong>接口处理数据</li>
<li>得到格式化的JSON数据</li>
</ol>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/copy-1.gif" alt=""></p>

<blockquote>
<p>不仅仅是对象，copy接口对任何数据都可以进行拷贝，这里利用的是copy在拷贝数组或对象过程中，对数据进行美化的功能</p>
</blockquote>

<h2>iframe 调试</h2>

<p>如果我们使用Webpack服务器工具<a href="https://webpack.github.io/docs/webpack-dev-server.html">webpack-dev-server</a>访问项目的开发页面，我们会发现，开发页面被内嵌到了iframe中进行渲染。</p>

<p>由于Chrome控制台默认的上下文是<code>window.top</code>，控制台中无法直接对内嵌在iframe的开发页面进行操作。如果我们想对iframe中的页面进行DOM操作，或者执行类库API，首先我们通过contentWindow来获取到iframe的上下文，然后使用with语句进行调试:</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// html</span>
<span class="o">&lt;</span><span class="nx">iframe</span> <span class="nx">id</span><span class="o">=</span><span class="s2">&quot;iframe&quot;</span><span class="o">&gt;&lt;</span><span class="err">/iframe&gt;</span>

<span class="c1">// 控制台</span>
<span class="kd">with</span> <span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;iframe&#39;</span><span class="p">).</span><span class="nx">contentWindow</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">inspect</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>

    <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span> <span class="cm">/* ... */</span> <span class="p">});</span>

    <span class="c1">// do something...</span>
<span class="p">}</span>
</code></pre></div>
<p>以上方法可以在任意浏览器上使用，但如果我们使用的是Chrome浏览器，Chrome控制台的上下文切换功能会更加方便：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/iframe-1.gif" alt=""></p>

<p>我们将上下文切换到iframe中，控制台的代码都会基于iframe的上下文来执行。如果你用webpack-dev-server进行调试，你会感谢这个功能。</p>

<h2>debug 毫无用处？</h2>

<p>Chrome控制台提供debug接口，可以传入一个函数，当这个函数下次执行的时候，调试器会自动在该函数中进行断点调试。</p>

<p>我们明明可以在代码中设置断点进行调试，为什么要用到debug来设置，是为了舍弃鼠标用命令行装逼而已吗？</p>

<p>在我看来，debug函数还提供了定位功能，它能够让我们很快的找到指定的函数。下面演示怎么调试VueJS的数据驱动，如何找到VueJS数据驱动的代码入口。</p>

<p>我们都知道，VueJS的数据驱动是通过<a href="http://devdocs.io/javascript/global_objects/object/defineproperty">defineProperty</a>方法对数据的getter和setter进行封装，在这个封装中实现数据变化驱动视图同步修改的功能。如果我们想研究VueJS的数据驱动，那么首先要找到封装getter和setter的地方，我们可以通过debug接口来进行定位。以下用getter方法举例。</p>

<p>首先我们知道VueJS实例中的数据都是映射<code>_data</code>属性中的值：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="kd">var</span> <span class="nx">vm</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
    <span class="nx">data</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;lxjwlt&#39;</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="nx">vm</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">_data</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div>
<p>所以我们要找的数据实际在VueJS实例的<code>_data</code>属性中。接下来我们通过<a href="http://devdocs.io/javascript/global_objects/object/getownpropertydescriptor">getOwnPropertyDescriptor</a>获取数据的getter函数：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">_data</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">).</span><span class="nx">get</span><span class="p">;</span>
</code></pre></div>
<p>找到了getter函数，我们就可以使用debug接口对其进行断点调试：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">debug</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">vm</span><span class="p">.</span><span class="nx">_data</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">).</span><span class="nx">get</span><span class="p">)</span>
</code></pre></div>
<p>这样，当我们获取<code>vm.name</code>数据时，自然会触发该数据的getter函数，从而触发断点调试，自动定位到了函数所在的地方：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/debug-1.gif" alt=""></p>

<p>日后要调试或者<strong>定位</strong>公共API，不妨试试Chrome的debug接口功能！</p>

<h2>条件breakpoint</h2>

<p>在Chrome中，我们可以给断点设置表达式，当表达式为true时断点调试才会生效，这就是条件断点。</p>

<p>有了条件断点，我们在调试代码的时候能够更加精确的控制代码断点的时机，特别是一段代码会被反复运行的时候，条件断点能够跳过大多数情况，只关注我们想要的情景。除了这一点外，条件断点调试还有另一个用法。</p>

<p>在断点调试中，我们往往会检查当前代码的执行状态，如果操作比较繁琐，那么我们可以使用条件断点添加<strong>自动化操作</strong>，帮助我们减少一部分工作量。</p>

<p>比如我们要在断点发生后查看DOM元素，那么断点条件可以这么写：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="c1">// 当DOM元素满足某个条件进行断点，同时查看这个元素</span>
<span class="nx">elem</span><span class="p">.</span><span class="nx">hasAttribute</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">inspect</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
</code></pre></div>
<p>如果不清楚操作的返回值，我们可以强行让该操作返回true，从而不影响断点的条件判断：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">elem</span><span class="p">.</span><span class="nx">hasAttribute</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">inspect</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span> <span class="o">||</span> <span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p>或者分行写：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="k">if</span> <span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">hasAttribute</span><span class="p">(</span><span class="s1">&#39;class&#39;</span><span class="p">))</span> <span class="p">{</span><span class="nx">inspect</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span> <span class="kc">true</span><span class="p">;}</span>
</code></pre></div>
<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/breakpoint-1.gif" alt=""></p>

<p>再比如，在VueJS的调试中，我们往往需要知道VueJS实例的当前状态，所以每次触发断点调试时，我们可以先使用clear接口清除控制台历史输出，再将VueJS实例的当前状态打印出来：</p>
<div class="highlight"><pre><code class="language-js" data-lang="js"><span class="nx">vm</span><span class="p">.</span><span class="nx">sum</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">clear</span><span class="p">()</span> <span class="o">||</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">$log</span><span class="p">()</span> <span class="o">||</span> <span class="kc">true</span><span class="p">);</span>
</code></pre></div>
<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/breakpoint-2.gif" alt=""></p>

<blockquote>
<p>如果在条件断点中定义变量，变量是定义到全局作用域上，即window对象上的</p>
</blockquote>

<h2>Async调试</h2>

<p>Chrome调试器的Async模式是为调试异步函数所设计一个功能。</p>

<p>在Promise被广泛应用的今天，我们都知道，Promise的回调是异步执行的，没有开启Async模式前，调动栈只记录到回调函数本身，我们无法找到代码执行的顺序，这给我们调试带来巨大的困难。Async模式可以解决这个问题：</p>

<p><img src="http://7xslv0.com1.z0.glb.clouddn.com/chrome-debug/async.gif" alt=""></p>

<p>开启Async模式后，异步函数之前的调用栈都会被记录下来，而且调用栈中代码执行状态也得到了保留。</p>

<h2>更多阅读</h2>

<ul>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/debug/console/console-reference?utm_source=dcc">Chrome Console Reference</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/debug/command-line/command-line-reference?utm_source=dcc">Chrome Command Line Reference</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/developertools/async-call-stack/">Debugging Asynchronous JavaScript with Chrome DevTools</a></li>
<li><a href="http://bahmutov.calepin.co/chrome-devtools-code-snippets.html">Chrome DevTools Code Snippets</a></li>
</ul>

        		<!-- Duoshuo Comment BEGIN -->
        		<div class="ds-thread"></div>
        		<script type="text/javascript">
        			var duoshuoQuery = {short_name:"lxjwlt"};
        			(function() {
        				var ds = document.createElement('script');
        				ds.type = 'text/javascript';ds.async = true;
        				ds.src = 'http://static.duoshuo.com/embed.js';
        				ds.charset = 'UTF-8';
        				(document.getElementsByTagName('head')[0]
        				|| document.getElementsByTagName('body')[0]).appendChild(ds);
        			})();
        		</script>
        		<!-- Duoshuo Comment END -->
        	</div>
        </div>

        <script src="/scripts/sea.js"></script>
        <script>
            seajs.use('post');
        </script>
    </body>
</html>
